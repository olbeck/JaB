% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jab-network.R
\name{jab_network}
\alias{jab_network}
\title{JaB Algorithm for Network Data}
\usage{
jab_network(
  network,
  central.func.name,
  central.package.name = NULL,
  central.func.args = NULL,
  bootstrap.func.name,
  bootstrap.package.name = NULL,
  bootstrap.func.args = NULL,
  B = 1000,
  quant = 0.95,
  nodes = NULL,
  return.boot.samples = FALSE
)
}
\arguments{
\item{network}{The network as an \code{igraph} object.}

\item{central.func.name}{A character string of the function name used to calculate the desired centrality statistic.}

\item{central.package.name}{(Optional) A character string of the name of the package that the \code{central.func.name} function is in. If left as \code{NULL} if the function will be called as loaded in the users environment.}

\item{central.func.args}{(Optional) A list of additional arguments the \code{central.func.name} function may need beyond the \code{network} object.}

\item{bootstrap.func.name}{A character string of the \code{JaB::boostrap_} function name used to generate bootstrap samples. (e.g. \code{\link[=bootstrap_snowboot]{bootstrap_snowboot()}})}

\item{bootstrap.package.name}{(Optional) A character string of the name of the package that the \code{bootstrap.func.name} function is in. If left as \code{NULL} if the function will be called as loaded in the users environment.}

\item{bootstrap.func.args}{(Optional) A list of additional arguments the \code{bootstrap.func.name} function may need beyond the \code{network} object.}

\item{B}{Number of bootstrap samples. Default is 1,000.}

\item{quant}{A numeric value specifying the upper quantile used to flag influential nodes (e.g., \code{0.95}).}

\item{nodes}{(Optional) A vector of node names to run JaB algorithm for. If \code{NULL}, algorithm will be run on all \eqn{n} nodes in \code{network}.}

\item{return.boot.samples}{Logical, should list of bootstrap samples used in algorithm be returned? Default is \code{FALSE}.}
}
\value{
If \code{return.boot.samples} is \code{FALSE}, returns a data frame containing:
\itemize{
\item \code{Node_Number}: Numeric IDs of nodes.
\item \code{Node_Name}: Name of nodes.
\item \code{Orig_Stat}: The original centrality statistic of each node.
\item \code{Boot_mean}, \code{Boot_sd}, \code{Boot_skew}: The mean, standard deviation, and skewness of the elements of \eqn{\Gamma_i}
\item \code{Upper_Quantile}: Upper quantile of the jackknife-after-bootstrap distribution of centrality statistic for each node.
\item \code{Influential}: Logical indicating if each node is influential, i.e. is \code{Orig_Stat} greater than \code{Upper_Quantile}?
\item \code{Rank}: Rank from most (1) to least (\eqn{n}) influential. There can be ties in the rankings.
\item \code{Can_Jackknife}: Logical indicating if there were bootstrap samples that
\emph{did not} include that node, meaning there \emph{are} jackknife-after sample to generate
the distribution of centrality statistics in networks that do not contain that node.
If \code{FALSE}, then all bootstrap samples contained that node and the \code{Upper_Quantile} column will generally be \code{NA}.
If many nodes are \code{FALSE} it could mean that the bootstrap method is poorly tuned and is
sampling more nodes that is appropriate for this data set.
If only a few nodes are \code{FALSE} it could mean the bootstrap method is
poorly tuned for this data set, or it could mean that the node is extremely influential as
it is highly improbable to generate a bootstrap sample that does not contain that node.
Which explanation is appropriate depends on the data set and the bootstrap method used.
\item \code{Num_Boot_Samps}: Number of bootstrap samples used to construct the distribution in the Jackknife-after step.
If there are \eqn{B} bootstrap samples in \code{boot.result}, then \eqn{B - Num_Boot_Samps}
bootstrap samples \emph{contained} node \eqn{v_i} and, \eqn{Num_Boot_Samps} \emph{did not contain} node \eqn{v_i}
If \code{Can_Jackknife} is \code{FALSE}, then this number will be 0 (i.e. \emph{all} bootstrap samples contained
node \eqn{v_i} and thus \emph{none} of them can be used in the Jackknife-after step).
}

If \code{return.boot.samples} is \code{TRUE}, returns a list containing,
\enumerate{
\item \code{bootstrap}: List of \code{B} bootstrap samples.
\item \code{jack.after}: Results of the JaB algorithm as the data frame listed above.
}
}
\description{
Wrapper function for the Jackknife-after-Bootstrap (JaB) algorithm for networks.
}
\details{
Suppose we have a network \eqn{G} with \eqn{n} nodes. Specify a centrality statistic \eqn{\gamma}.

For each node \eqn{i = 1,...,n} we test the hypotheses \eqn{H_0}:
node \eqn{i} is not influential to the network, versus \eqn{H_1}: node \eqn{i}
is influential to the network.

Define \eqn{q\in [0, 1]} as the upper quantile cut off value and \eqn{B} as
the number of bootstrap samples.

The JaB algorithm has three steps:
\enumerate{
\item \strong{Original Centrality Step}: Calculate \eqn{n} centrality statistics of the
original network, \eqn{\gamma_1, \gamma_2, ..., \gamma_n}.
\item \strong{Bootstrapping Step}: Generate bootstrap samples \eqn{G\pb=(V\pb, E\pb)}
for \eqn{b=1,...,B}. For each bootstrap sample, calculate \eqn{\{\gamma_j\pb : j=1,...,n\}}.
\item \strong{Jackknife-after Step}: For \eqn{i \in 1,...,n}, do:

A. Calculate \eqn{S_i^{*b} = \boldsymbol{1}(v_i \in V^{*b})} for \eqn{b=1,...,B}
and construct \eqn{\mathcal{B}_{-i} = \{G^{*b}: S_i^{*b} = 0)} which is the set of
all bootstrap sample networks that \emph{do not} contain node \emph{i}.

B. Let \eqn{\Gamma_{-i} = \{\gamma_j^{*b} : G^{*b} \in \mathcal{B}_{-i}, j=1,...,n\}}
be the set of all centrality statistics calculated from all bootstrap sample
networks that \emph{do not} contain node \emph{i}.

C. Calculate the cutoff value, \eqn{q_{-i}}, the \eqn{q^{\text{th}}}
quantile of \eqn{\Gamma^{-i}}.

D. If \eqn{\gamma_i > q_{-i}}, reject  null hypothesis for node \eqn{i}
and conclude that node \eqn{i} is influential.
}

Once we run the algorithm, we have a set of nodes that are influential a set of nodes that are not.

We can also generate a ranking of all nodes from most to least influential
determined by \eqn{\gamma_i - q_i} in step 3C. Node \eqn{i} is considered influential
when \eqn{\gamma_i - q_i} is large and positive, somewhat influential when \eqn{\gamma_i - q_i}
is small and positive, somewhat not influential when \eqn{\gamma_i - q_i}, and
very not influential when \eqn{\gamma_i - q_i} is large and negative.

We construct bootstrap standard errors and confidence intervals the bootstrap samples generated in Step 2 this algorithm.
Let \eqn{\mathcal{B}_i = \{G^{*b} : S_i^{*b} = 1\}} be the set of all bootstrap
networks that include \eqn{v_i} and \eqn{\Gamma_i = \{\gamma_j : v_j\pb = v_i , v_j\pb \in V\pb\}}
be the set of centrality statistics corresponding to the nodes that are sampled to be \eqn{v_i}.
Then the bootstrap standard error of \eqn{\gamma_i} is \eqn{\sigma_i^{ *} = \sqrt{(|\Gamma_i |-1)^{-1} \sum_{\gamma_j \in \Gamma_i} (\gamma_j - \Bar{\gamma}_i)^2}}
where \eqn{\Bar{\gamma}_i = |\Gamma_i|^{-1}\sum_{\gamma_j \in \Gamma_i} \gamma_j}.
Using \eqn{\sigma_i^{ *}}, bootstrap confidence intervals are constructed in the traditional way.
For example, a 95\% bootstrap confidence interval for \eqn{\gamma_i} is \eqn{(\gamma_i - 1.96\sigma_i^{ *} , \gamma_i + 1.96\sigma_i^{ *})}.
For many centrality statistics \eqn{\gamma_i} must be a non-negative value.
If it is the case that \eqn{\gamma_i} must be non-negative and  \eqn{\gamma_i - 1.96\sigma_i^{ *}<0},
we set the 95\% bootstrap confidence interval to be \eqn{(0, \gamma_i + 1.96\sigma_i^{ *})}.

By construction \eqn{\mathcal{B}_i \cap \mathcal{B}_{-i} = \emptyset}.
The bootstrap samples in \eqn{\mathcal{B}_i} are used for the bootstrap standard
errors and the bootstrap samples in \eqn{\mathcal{B}_{-i}} are used for the
hypothesis test of node $v_i$'s influence.

\code{jab_network} is a wrapper function for the entire JaB algorithm. For each step of the JaB algorithm,
the following functions are used:
\enumerate{
\item \strong{Original Centrality Step}: Calculate the original centrality statistics using \code{\link[=get_centrality]{get_centrality()}} according to \code{central.func.name}.
\item \strong{Bootstrapping Step}: Generate Bootstrap samples according to \code{bootstrap.func.name} and calculate their
centrality statistics using \code{\link[=get_bootstrap_centrality]{get_bootstrap_centrality()}}.
\item \strong{Jackknife-after Step}: Perform the "Jackknife-after" step of the algorithm with \code{\link[=get_jackknife_after]{get_jackknife_after()}}.
}

See \code{vignette("jab-networks")} for more details and examples.
}
\examples{
library(igraphdata)
library(igraph)
data(karate)

# JaB with snowboot (1 seed and 2 waves), 1000 bootstrap samples,
# degree (from igraph), and cutoff quantile of 0.90

jab_network(
  network = karate,
  central.func.name = "degree",
  central.package.name = "igraph",
  central.func.args = list(normalized = TRUE),
  bootstrap.func.name = "bootstrap_snowboot" ,
  bootstrap.package.name = "JaB" ,
  bootstrap.func.args = list( num.seed = 1, num.wave = 2 ),
  B = 1000,
  quant = 0.90,
  nodes = NULL,
  return.boot.samples = FALSE)
}
\seealso{
\code{\link[=get_centrality]{get_centrality()}},  \code{\link[=get_bootstrap_centrality]{get_bootstrap_centrality()}}, \code{\link[=get_jackknife_after]{get_jackknife_after()}}
}
